$color-primary: #55c57a;
$color-primary-light: #7ed56f;
$color-primary-dark: #28b485;

$color-grey-dark: #777;
$color-white: #fff;
$color-black: #000;

/* The inherit keyword forces inheritance. (See box-sizing specifications in body.) */
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
}

/* By setting the root font size to a percentage (rather than a pixel value),
the font size will be determined as a percentage of the font size given by the browser.
This is best practice, so if users accessing the page have a specified font size setting,
then the font will adjust according the to their specifications.
This will be considered the root for the rem values.
Otherwise, the root will stay as the pixel value you provide.
The default browser font size is 16px.
Below, we want 10px as the root, so we found the percentage 10 is of 16. */
/* FYI: rem is  not supported below IE9 */
html {
  font-size: 62.5%;
}

/* https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/ */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: $color-grey-dark;
  padding: 3rem;

  box-sizing: border-box;
}

.header {
  height: 95vh;
  background-image: linear-gradient(
      to right bottom,
      rgba($color-primary-light, 0.8),
      rgba($color-primary-dark, 0.8)
    ),
    url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;

  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);

  &__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem;
  }

  &__logo {
    height: 3.5rem;
  }

  /* The translate transformation is in relation to the element itself. */
  /* The element is shifted 50% of its width to the left and 50% of its height to the top. */
  &__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    text-align: center;

    transform: translate(-50%, -50%);
    -webkit-transform: translate(-50%, -50%);
    -moz-transform: translate(-50%, -50%);
    -ms-transform: translate(-50%, -50%);
    -o-transform: translate(-50%, -50%);
  }
}

/* The backface-visibilty is meant to refer to the backside of an element.
    In this case, it is preventing animation side effects (like shifts) .*/
.heading-primary {
  color: $color-white;
  text-transform: uppercase;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  margin-bottom: 6rem;

  /* All span elements are inline by default.
      The display block creates line breaks because it takes up 100% of the width, which allows 2-lined h1. */
  /* The animation properties apply the @keyframes rules. */
  &--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;

    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out;
    /*
    animation-delay: 3s;
    animation-iteration-count: 3;
    */
  }

  /* The animation property is short-hand for the animation properties in heading-primary-main. */
  &--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;

    animation: moveInRight 1s ease-out;
    -webkit-animation: moveInRight 1s ease-out;
  }
}

/* Custom animations can be created with @keyframes rule.
    For browser performance, IT'S BEST TO ONLY ANIMATE OPACITY AND TRANSFORM PROPERTIES.
    That's what browsers are optimized for. */

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
    -webkit-transform: translateX(-10rem);
    -moz-transform: translateX(-10rem);
    -ms-transform: translateX(-10rem);
    -o-transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
    -webkit-transform: translateX(1rem);
    -moz-transform: translateX(1rem);
    -ms-transform: translateX(1rem);
    -o-transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
    -webkit-transform: translate(0);
    -moz-transform: translate(0);
    -ms-transform: translate(0);
    -o-transform: translate(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
    -webkit-transform: translateX(10rem);
    -moz-transform: translateX(10rem);
    -ms-transform: translateX(10rem);
    -o-transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
    -webkit-transform: translateX(-1rem);
    -moz-transform: translateX(-1rem);
    -ms-transform: translateX(-1rem);
    -o-transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
    -webkit-transform: translateX(0);
    -moz-transform: translateX(0);
    -ms-transform: translateX(0);
    -o-transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
    -webkit-transform: translateY(3rem);
    -moz-transform: translateY(3rem);
    -ms-transform: translateY(3rem);
    -o-transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translateY(0);
    -webkit-transform: translateY(0);
    -moz-transform: translateY(0);
    -ms-transform: translateY(0);
    -o-transform: translateY(0);
  }
}

/* link & visited are pseudo-classes (a special state of a selector) */
/* The inline-block displays an element as inline-level block container.
    This treats the element as if it is text, so the parent class (aka text-box) should use text-align to center. */
/* A high border-radius will have the same effect.
    Ex: 100px will display the same as 500px */
/* The transition property is the simpler method to perform an animation (compared to @keyframes).
    It allows a smooth gradual change through a specified timeframe.
    Here, all is specified, so all properties (translations in hover and active) will be animated with transition. */

.btn {
  &:link,
  &:visited {
    font-size: 1.6rem;
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    display: inline-block;
    border-radius: 10rem;
    -webkit-border-radius: 10rem;
    -moz-border-radius: 10rem;
    -ms-border-radius: 10rem;
    -o-border-radius: 10rem;
    transition: all 0.2s;
    -webkit-transition: all 0.2s;
    -moz-transition: all 0.2s;
    -ms-transition: all 0.2s;
    -o-transition: all 0.2s;
    position: relative;
  }

  /* To give the effect of pressing a button, adjust box-shadow.
  box-shadow: [x] [y] [blur] [rgba(r, g, b, opacity)] */

  &:hover {
    transform: translateY(-3px);
    -webkit-transform: translateY(-3px);
    -moz-transform: translateY(-3px);
    -ms-transform: translateY(-3px);
    -o-transform: translateY(-3px);
    box-shadow: 0 1rem 2rem rgba($color-black, 0.2);

    &::after {
      opacity: 0;
      transform: scaleX(1.4) scaleY(1.6);
      -webkit-transform: scaleX(1.4) scaleY(1.6);
      -moz-transform: scaleX(1.4) scaleY(1.6);
      -ms-transform: scaleX(1.4) scaleY(1.6);
      -o-transform: scaleX(1.4) scaleY(1.6);
    }
  }

  /* The active pseudo-class reprecents when the link is clicked. */
  /* Transformations are in relation to the initial state - NOT the previous state. */
  &:active {
    transform: translateY(-1px);
    -webkit-transform: translateY(-1px);
    -moz-transform: translateY(-1px);
    -ms-transform: translateY(-1px);
    -o-transform: translateY(-1px);

    box-shadow: 0 0.5rem 1rem rgba($color-black, 0.2);
  }

  &--white {
    background-color: $color-white;
    color: $color-grey-dark;

    &::after {
      background-color: $color-white;
    }
  }

  /* ::after is a pseudo-element
      It acts like a virtual child element after the element selected.
      The content and display properties are required for ::after.
      Setting the position as absolute in relation to the parent will allow it to be in the same place as the parent.
      Setting the z-index to -1 makes sure this is behind the parent. */

  &::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all 0.4s;
    -webkit-transition: all 0.4s;
    -moz-transition: all 0.4s;
    -ms-transition: all 0.4s;
    -o-transition: all 0.4s;
    -webkit-border-radius: 10rem;
    -moz-border-radius: 10rem;
    -ms-border-radius: 10rem;
    -o-border-radius: 10rem;
  }

  /* animation: [name] [duration] [timing-function] [delay] */
  /* The animation-fill-mode property specifies a style for the element when the animation is not playing.
      Below it is set as backwards, which will use moveInBottom at the 0% keyframe properties during the delay. */

  &--animated {
    animation: moveInBottom 0.5s ease-out 0.75s;
    -webkit-animation: moveInBottom 0.5s ease-out 0.75s;
    animation-fill-mode: backwards;
  }
}
